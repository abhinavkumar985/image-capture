import { CommonModule } from '@angular/common';
import { Component, EventEmitter, Input, Output, ViewChild, NgModule } from '@angular/core';
import 'rxjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Container class for a captured webcam image
 * @author basst314, davidshen84
 */
var  /**
 * Container class for a captured webcam image
 * @author basst314, davidshen84
 */
WebcamImage = /** @class */ (function () {
    function WebcamImage(imageAsDataUrl, mimeType, imageData) {
        this._mimeType = null;
        this._imageAsBase64 = null;
        this._imageAsDataUrl = null;
        this._imageData = null;
        this._mimeType = mimeType;
        this._imageAsDataUrl = imageAsDataUrl;
        this._imageData = imageData;
    }
    /**
     * Extracts the Base64 data out of the given dataUrl.
     * @param dataUrl the given dataUrl
     * @param mimeType the mimeType of the data
     */
    /**
     * Extracts the Base64 data out of the given dataUrl.
     * @private
     * @param {?} dataUrl the given dataUrl
     * @param {?} mimeType the mimeType of the data
     * @return {?}
     */
    WebcamImage.getDataFromDataUrl = /**
     * Extracts the Base64 data out of the given dataUrl.
     * @private
     * @param {?} dataUrl the given dataUrl
     * @param {?} mimeType the mimeType of the data
     * @return {?}
     */
    function (dataUrl, mimeType) {
        return dataUrl.replace("data:" + mimeType + ";base64,", '');
    };
    Object.defineProperty(WebcamImage.prototype, "imageAsBase64", {
        /**
         * Get the base64 encoded image data
         * @returns base64 data of the image
         */
        get: /**
         * Get the base64 encoded image data
         * @return {?} base64 data of the image
         */
        function () {
            return this._imageAsBase64 ? this._imageAsBase64
                : this._imageAsBase64 = WebcamImage.getDataFromDataUrl(this._imageAsDataUrl, this._mimeType);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebcamImage.prototype, "imageAsDataUrl", {
        /**
         * Get the encoded image as dataUrl
         * @returns the dataUrl of the image
         */
        get: /**
         * Get the encoded image as dataUrl
         * @return {?} the dataUrl of the image
         */
        function () {
            return this._imageAsDataUrl;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebcamImage.prototype, "imageData", {
        /**
         * Get the ImageData object associated with the canvas' 2d context.
         * @returns the ImageData of the canvas's 2d context.
         */
        get: /**
         * Get the ImageData object associated with the canvas' 2d context.
         * @return {?} the ImageData of the canvas's 2d context.
         */
        function () {
            return this._imageData;
        },
        enumerable: true,
        configurable: true
    });
    return WebcamImage;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var WebcamUtil = /** @class */ (function () {
    function WebcamUtil() {
    }
    /**
     * Lists available videoInput devices
     * @returns a list of media device info.
     */
    /**
     * Lists available videoInput devices
     * @return {?} a list of media device info.
     */
    WebcamUtil.getAvailableVideoInputs = /**
     * Lists available videoInput devices
     * @return {?} a list of media device info.
     */
    function () {
        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
            return Promise.reject('enumerateDevices() not supported.');
        }
        return new Promise(function (resolve, reject) {
            navigator.mediaDevices.enumerateDevices()
                .then(function (devices) {
                resolve(devices.filter(function (device) { return device.kind === 'videoinput'; }));
            })
                .catch(function (err) {
                reject(err.message || err);
            });
        });
    };
    return WebcamUtil;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var WebcamComponent = /** @class */ (function () {
    function WebcamComponent() {
        /**
         * Defines the max width of the webcam area in px
         */
        this.width = 640;
        /**
         * Defines the max height of the webcam area in px
         */
        this.height = 480;
        /**
         * Defines base constraints to apply when requesting video track from UserMedia
         */
        this.videoOptions = WebcamComponent.DEFAULT_VIDEO_OPTIONS;
        /**
         * Flag to enable/disable camera switch. If enabled, a switch icon will be displayed if multiple cameras were found
         */
        this.allowCameraSwitch = true;
        /**
         * Flag to control whether an ImageData object is stored into the WebcamImage object.
         */
        this.captureImageData = false;
        /**
         * The image type to use when capturing snapshots
         */
        this.imageType = WebcamComponent.DEFAULT_IMAGE_TYPE;
        /**
         * The image quality to use when capturing snapshots (number between 0 and 1)
         */
        this.imageQuality = WebcamComponent.DEFAULT_IMAGE_QUALITY;
        /**
         * EventEmitter which fires when an image has been captured
         */
        this.imageCapture = new EventEmitter();
        /**
         * Emits a mediaError if webcam cannot be initialized (e.g. missing user permissions)
         */
        this.initError = new EventEmitter();
        /**
         * Emits when the webcam video was clicked
         */
        this.imageClick = new EventEmitter();
        /**
         * Emits the active deviceId after the active video device was switched
         */
        this.cameraSwitched = new EventEmitter();
        /**
         * available video devices
         */
        this.availableVideoInputs = [];
        /**
         * Indicates whether the video device is ready to be switched
         */
        this.videoInitialized = false;
        /**
         * Index of active video in availableVideoInputs
         */
        this.activeVideoInputIndex = -1;
        /**
         * MediaStream object in use for streaming UserMedia data
         */
        this.mediaStream = null;
        /**
         * width and height of the active video stream
         */
        this.activeVideoSettings = null;
    }
    Object.defineProperty(WebcamComponent.prototype, "trigger", {
        /**
         * If the given Observable emits, an image will be captured and emitted through 'imageCapture' EventEmitter
         */
        set: /**
         * If the given Observable emits, an image will be captured and emitted through 'imageCapture' EventEmitter
         * @param {?} trigger
         * @return {?}
         */
        function (trigger) {
            var _this = this;
            if (this.triggerSubscription) {
                this.triggerSubscription.unsubscribe();
            }
            // Subscribe to events from this Observable to take snapshots
            this.triggerSubscription = trigger.subscribe(function () {
                _this.takeSnapshot();
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebcamComponent.prototype, "switchCamera", {
        /**
         * If the given Observable emits, the active webcam will be switched to the one indicated by the emitted value.
         * @param switchCamera Indicates which webcam to switch to
         *   true: cycle forwards through available webcams
         *   false: cycle backwards through available webcams
         *   string: activate the webcam with the given id
         */
        set: /**
         * If the given Observable emits, the active webcam will be switched to the one indicated by the emitted value.
         * @param {?} switchCamera Indicates which webcam to switch to
         *   true: cycle forwards through available webcams
         *   false: cycle backwards through available webcams
         *   string: activate the webcam with the given id
         * @return {?}
         */
        function (switchCamera) {
            var _this = this;
            if (this.switchCameraSubscription) {
                this.switchCameraSubscription.unsubscribe();
            }
            // Subscribe to events from this Observable to switch video device
            this.switchCameraSubscription = switchCamera.subscribe(function (value) {
                if (typeof value === 'string') {
                    // deviceId was specified
                    _this.switchToVideoInput(value);
                }
                else {
                    // direction was specified
                    _this.rotateVideoInput(value !== false);
                }
            });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get MediaTrackConstraints to request streaming the given device
     * @param deviceId
     * @param baseMediaTrackConstraints base constraints to merge deviceId-constraint into
     * @returns
     */
    /**
     * Get MediaTrackConstraints to request streaming the given device
     * @private
     * @param {?} deviceId
     * @param {?} baseMediaTrackConstraints base constraints to merge deviceId-constraint into
     * @return {?}
     */
    WebcamComponent.getMediaConstraintsForDevice = /**
     * Get MediaTrackConstraints to request streaming the given device
     * @private
     * @param {?} deviceId
     * @param {?} baseMediaTrackConstraints base constraints to merge deviceId-constraint into
     * @return {?}
     */
    function (deviceId, baseMediaTrackConstraints) {
        /** @type {?} */
        var result = baseMediaTrackConstraints ? baseMediaTrackConstraints : this.DEFAULT_VIDEO_OPTIONS;
        if (deviceId) {
            result.deviceId = { exact: deviceId };
        }
        return result;
    };
    /**
     * Tries to harvest the deviceId from the given mediaStreamTrack object.
     * Browsers populate this object differently; this method tries some different approaches
     * to read the id.
     * @param mediaStreamTrack
     * @returns deviceId if found in the mediaStreamTrack
     */
    /**
     * Tries to harvest the deviceId from the given mediaStreamTrack object.
     * Browsers populate this object differently; this method tries some different approaches
     * to read the id.
     * @private
     * @param {?} mediaStreamTrack
     * @return {?} deviceId if found in the mediaStreamTrack
     */
    WebcamComponent.getDeviceIdFromMediaStreamTrack = /**
     * Tries to harvest the deviceId from the given mediaStreamTrack object.
     * Browsers populate this object differently; this method tries some different approaches
     * to read the id.
     * @private
     * @param {?} mediaStreamTrack
     * @return {?} deviceId if found in the mediaStreamTrack
     */
    function (mediaStreamTrack) {
        if (mediaStreamTrack.getSettings && mediaStreamTrack.getSettings() && mediaStreamTrack.getSettings().deviceId) {
            return mediaStreamTrack.getSettings().deviceId;
        }
        else if (mediaStreamTrack.getConstraints && mediaStreamTrack.getConstraints() && mediaStreamTrack.getConstraints().deviceId) {
            /** @type {?} */
            var deviceIdObj = mediaStreamTrack.getConstraints().deviceId;
            return WebcamComponent.getValueFromConstrainDOMString(deviceIdObj);
        }
    };
    /**
     * Tries to harvest the facingMode from the given mediaStreamTrack object.
     * Browsers populate this object differently; this method tries some different approaches
     * to read the value.
     * @param mediaStreamTrack
     * @returns facingMode if found in the mediaStreamTrack
     */
    /**
     * Tries to harvest the facingMode from the given mediaStreamTrack object.
     * Browsers populate this object differently; this method tries some different approaches
     * to read the value.
     * @private
     * @param {?} mediaStreamTrack
     * @return {?} facingMode if found in the mediaStreamTrack
     */
    WebcamComponent.getFacingModeFromMediaStreamTrack = /**
     * Tries to harvest the facingMode from the given mediaStreamTrack object.
     * Browsers populate this object differently; this method tries some different approaches
     * to read the value.
     * @private
     * @param {?} mediaStreamTrack
     * @return {?} facingMode if found in the mediaStreamTrack
     */
    function (mediaStreamTrack) {
        if (mediaStreamTrack) {
            if (mediaStreamTrack.getSettings && mediaStreamTrack.getSettings() && mediaStreamTrack.getSettings().facingMode) {
                return mediaStreamTrack.getSettings().facingMode;
            }
            else if (mediaStreamTrack.getConstraints && mediaStreamTrack.getConstraints() && mediaStreamTrack.getConstraints().facingMode) {
                /** @type {?} */
                var facingModeConstraint = mediaStreamTrack.getConstraints().facingMode;
                return WebcamComponent.getValueFromConstrainDOMString(facingModeConstraint);
            }
        }
    };
    /**
     * Determines whether the given mediaStreamTrack claims itself as user facing
     * @param mediaStreamTrack
     */
    /**
     * Determines whether the given mediaStreamTrack claims itself as user facing
     * @private
     * @param {?} mediaStreamTrack
     * @return {?}
     */
    WebcamComponent.isUserFacing = /**
     * Determines whether the given mediaStreamTrack claims itself as user facing
     * @private
     * @param {?} mediaStreamTrack
     * @return {?}
     */
    function (mediaStreamTrack) {
        /** @type {?} */
        var facingMode = WebcamComponent.getFacingModeFromMediaStreamTrack(mediaStreamTrack);
        return facingMode ? 'user' === facingMode.toLowerCase() : false;
    };
    /**
     * Extracts the value from the given ConstrainDOMString
     * @param constrainDOMString
     */
    /**
     * Extracts the value from the given ConstrainDOMString
     * @private
     * @param {?} constrainDOMString
     * @return {?}
     */
    WebcamComponent.getValueFromConstrainDOMString = /**
     * Extracts the value from the given ConstrainDOMString
     * @private
     * @param {?} constrainDOMString
     * @return {?}
     */
    function (constrainDOMString) {
        if (constrainDOMString) {
            if (constrainDOMString instanceof String) {
                return String(constrainDOMString);
            }
            else if (Array.isArray(constrainDOMString) && Array(constrainDOMString).length > 0) {
                return String(constrainDOMString[0]);
            }
            else if (typeof constrainDOMString === 'object') {
                if (constrainDOMString['exact']) {
                    return String(constrainDOMString['exact']);
                }
                else if (constrainDOMString['ideal']) {
                    return String(constrainDOMString['ideal']);
                }
            }
        }
        return null;
    };
    /**
     * @return {?}
     */
    WebcamComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.detectAvailableDevices()
            .then(function (devices) {
            // start first device
            _this.switchToVideoInput(devices.length > 0 ? devices[0].deviceId : null);
        })
            .catch(function (err) {
            _this.initError.next((/** @type {?} */ ({ message: err })));
            // fallback: still try to load webcam, even if device enumeration failed
            _this.switchToVideoInput(null);
        });
    };
    /**
     * @return {?}
     */
    WebcamComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.stopMediaTracks();
        this.unsubscribeFromSubscriptions();
    };
    /**
     * Takes a snapshot of the current webcam's view and emits the image as an event
     */
    /**
     * Takes a snapshot of the current webcam's view and emits the image as an event
     * @return {?}
     */
    WebcamComponent.prototype.takeSnapshot = /**
     * Takes a snapshot of the current webcam's view and emits the image as an event
     * @return {?}
     */
    function () {
        // set canvas size to actual video size
        /** @type {?} */
        var _video = this.video.nativeElement;
        /** @type {?} */
        var dimensions = { width: this.width, height: this.height };
        if (_video.videoWidth) {
            dimensions.width = _video.videoWidth;
            dimensions.height = _video.videoHeight;
        }
        /** @type {?} */
        var _canvas = this.canvas.nativeElement;
        _canvas.width = dimensions.width;
        _canvas.height = dimensions.height;
        // paint snapshot image to canvas
        /** @type {?} */
        var context2d = _canvas.getContext('2d');
        context2d.drawImage(this.video.nativeElement, 0, 0);
        // read canvas content as image
        /** @type {?} */
        var mimeType = this.imageType ? this.imageType : WebcamComponent.DEFAULT_IMAGE_TYPE;
        /** @type {?} */
        var quality = this.imageQuality ? this.imageQuality : WebcamComponent.DEFAULT_IMAGE_QUALITY;
        /** @type {?} */
        var dataUrl = _canvas.toDataURL(mimeType, quality);
        // get the ImageData object from the canvas' context.
        /** @type {?} */
        var imageData = null;
        if (this.captureImageData) {
            imageData = context2d.getImageData(0, 0, _canvas.width, _canvas.height);
        }
        this.imageCapture.next(new WebcamImage(dataUrl, mimeType, imageData));
    };
    /**
     * Switches to the next/previous video device
     * @param forward
     */
    /**
     * Switches to the next/previous video device
     * @param {?} forward
     * @return {?}
     */
    WebcamComponent.prototype.rotateVideoInput = /**
     * Switches to the next/previous video device
     * @param {?} forward
     * @return {?}
     */
    function (forward) {
        if (this.availableVideoInputs && this.availableVideoInputs.length > 1) {
            /** @type {?} */
            var increment = forward ? 1 : (this.availableVideoInputs.length - 1);
            /** @type {?} */
            var nextInputIndex = (this.activeVideoInputIndex + increment) % this.availableVideoInputs.length;
            this.switchToVideoInput(this.availableVideoInputs[nextInputIndex].deviceId);
        }
    };
    /**
     * Switches the camera-view to the specified video device
     */
    /**
     * Switches the camera-view to the specified video device
     * @param {?} deviceId
     * @return {?}
     */
    WebcamComponent.prototype.switchToVideoInput = /**
     * Switches the camera-view to the specified video device
     * @param {?} deviceId
     * @return {?}
     */
    function (deviceId) {
        this.videoInitialized = false;
        this.stopMediaTracks();
        this.initWebcam(deviceId, this.videoOptions);
    };
    /**
     * Event-handler for video resize event.
     * Triggers Angular change detection so that new video dimensions get applied
     */
    /**
     * Event-handler for video resize event.
     * Triggers Angular change detection so that new video dimensions get applied
     * @return {?}
     */
    WebcamComponent.prototype.videoResize = /**
     * Event-handler for video resize event.
     * Triggers Angular change detection so that new video dimensions get applied
     * @return {?}
     */
    function () {
        // here to trigger Angular change detection
    };
    Object.defineProperty(WebcamComponent.prototype, "videoWidth", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var videoRatio = this.getVideoAspectRatio();
            return Math.min(this.width, this.height * videoRatio);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebcamComponent.prototype, "videoHeight", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var videoRatio = this.getVideoAspectRatio();
            return Math.min(this.height, this.width / videoRatio);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebcamComponent.prototype, "videoStyleClasses", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var classes = '';
            if (this.isMirrorImage()) {
                classes += 'mirrored ';
            }
            return classes.trim();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the video aspect ratio of the active video stream
     */
    /**
     * Returns the video aspect ratio of the active video stream
     * @private
     * @return {?}
     */
    WebcamComponent.prototype.getVideoAspectRatio = /**
     * Returns the video aspect ratio of the active video stream
     * @private
     * @return {?}
     */
    function () {
        // calculate ratio from video element dimensions if present
        /** @type {?} */
        var videoElement = this.video.nativeElement;
        if (videoElement.videoWidth && videoElement.videoWidth > 0 &&
            videoElement.videoHeight && videoElement.videoHeight > 0) {
            return videoElement.videoWidth / videoElement.videoHeight;
        }
        // nothing present - calculate ratio based on width/height params
        return this.width / this.height;
    };
    /**
     * Init webcam live view
     */
    /**
     * Init webcam live view
     * @private
     * @param {?} deviceId
     * @param {?} userVideoTrackConstraints
     * @return {?}
     */
    WebcamComponent.prototype.initWebcam = /**
     * Init webcam live view
     * @private
     * @param {?} deviceId
     * @param {?} userVideoTrackConstraints
     * @return {?}
     */
    function (deviceId, userVideoTrackConstraints) {
        var _this = this;
        /** @type {?} */
        var _video = this.video.nativeElement;
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            // merge deviceId -> userVideoTrackConstraints
            /** @type {?} */
            var videoTrackConstraints = WebcamComponent.getMediaConstraintsForDevice(deviceId, userVideoTrackConstraints);
            navigator.mediaDevices.getUserMedia((/** @type {?} */ ({ video: videoTrackConstraints })))
                .then(function (stream) {
                _this.mediaStream = stream;
                _video.srcObject = stream;
                _video.play();
                _this.activeVideoSettings = stream.getVideoTracks()[0].getSettings();
                /** @type {?} */
                var activeDeviceId = WebcamComponent.getDeviceIdFromMediaStreamTrack(stream.getVideoTracks()[0]);
                _this.activeVideoInputIndex = activeDeviceId ? _this.availableVideoInputs
                    .findIndex(function (mediaDeviceInfo) { return mediaDeviceInfo.deviceId === activeDeviceId; }) : -1;
                _this.videoInitialized = true;
                _this.cameraSwitched.next(activeDeviceId);
            })
                .catch(function (err) {
                _this.initError.next((/** @type {?} */ ({ message: err.message, mediaStreamError: err })));
            });
        }
        else {
            this.initError.next((/** @type {?} */ ({ message: 'Cannot read UserMedia from MediaDevices.' })));
        }
    };
    /**
     * @private
     * @return {?}
     */
    WebcamComponent.prototype.getActiveVideoTrack = /**
     * @private
     * @return {?}
     */
    function () {
        return this.mediaStream ? this.mediaStream.getVideoTracks()[0] : null;
    };
    /**
     * @private
     * @return {?}
     */
    WebcamComponent.prototype.isMirrorImage = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.getActiveVideoTrack()) {
            return false;
        }
        // check for explicit mirror override parameter
        {
            /** @type {?} */
            var mirror = 'auto';
            if (this.mirrorImage) {
                if (typeof this.mirrorImage === 'string') {
                    mirror = String(this.mirrorImage).toLowerCase();
                }
                else {
                    // WebcamMirrorProperties
                    if (this.mirrorImage.x) {
                        mirror = this.mirrorImage.x.toLowerCase();
                    }
                }
            }
            switch (mirror) {
                case 'always':
                    return true;
                case 'never':
                    return false;
            }
        }
        // default: enable mirroring if webcam is user facing
        return WebcamComponent.isUserFacing(this.getActiveVideoTrack());
    };
    /**
     * Stops all active media tracks.
     * This prevents the webcam from being indicated as active,
     * even if it is no longer used by this component.
     */
    /**
     * Stops all active media tracks.
     * This prevents the webcam from being indicated as active,
     * even if it is no longer used by this component.
     * @private
     * @return {?}
     */
    WebcamComponent.prototype.stopMediaTracks = /**
     * Stops all active media tracks.
     * This prevents the webcam from being indicated as active,
     * even if it is no longer used by this component.
     * @private
     * @return {?}
     */
    function () {
        if (this.mediaStream && this.mediaStream.getTracks) {
            // getTracks() returns all media tracks (video+audio)
            this.mediaStream.getTracks()
                .forEach(function (track) { return track.stop(); });
        }
    };
    /**
     * Unsubscribe from all open subscriptions
     */
    /**
     * Unsubscribe from all open subscriptions
     * @private
     * @return {?}
     */
    WebcamComponent.prototype.unsubscribeFromSubscriptions = /**
     * Unsubscribe from all open subscriptions
     * @private
     * @return {?}
     */
    function () {
        if (this.triggerSubscription) {
            this.triggerSubscription.unsubscribe();
        }
        if (this.switchCameraSubscription) {
            this.switchCameraSubscription.unsubscribe();
        }
    };
    /**
     * Reads available input devices
     */
    /**
     * Reads available input devices
     * @private
     * @return {?}
     */
    WebcamComponent.prototype.detectAvailableDevices = /**
     * Reads available input devices
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            WebcamUtil.getAvailableVideoInputs()
                .then(function (devices) {
                _this.availableVideoInputs = devices;
                resolve(devices);
            })
                .catch(function (err) {
                _this.availableVideoInputs = [];
                reject(err);
            });
        });
    };
    WebcamComponent.DEFAULT_VIDEO_OPTIONS = { facingMode: 'environment' };
    WebcamComponent.DEFAULT_IMAGE_TYPE = 'image/jpeg';
    WebcamComponent.DEFAULT_IMAGE_QUALITY = 0.92;
    WebcamComponent.decorators = [
        { type: Component, args: [{
                    selector: 'webcam',
                    template: "<div class=\"webcam-wrapper\" (click)=\"imageClick.next();\">\r\n  <video #video [width]=\"videoWidth\" [height]=\"videoHeight\" [class]=\"videoStyleClasses\" autoplay muted playsinline (resize)=\"videoResize()\"></video>\r\n  <div class=\"camera-switch\" *ngIf=\"allowCameraSwitch && availableVideoInputs.length > 1 && videoInitialized\" (click)=\"rotateVideoInput(true)\"></div>\r\n  <canvas #canvas [width]=\"width\" [height]=\"height\"></canvas>\r\n</div>\r\n",
                    styles: [".webcam-wrapper{display:inline-block;position:relative;line-height:0}.webcam-wrapper video.mirrored{-webkit-transform:scale(-1,1);transform:scale(-1,1)}.webcam-wrapper canvas{display:none}.webcam-wrapper .camera-switch{background-color:rgba(0,0,0,.1);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAE9UlEQVR42u2aT2hdRRTGf+cRQqghSqihdBFDkRISK2KDfzDWxHaRQHEhaINKqa1gKQhd6EZLN+IidCH+Q0oWIkVRC21BQxXRitVaSbKoJSGtYGoK2tQ/tU1jY5v0c5F54Xl7b/KSO/PyEt+3e5f75p7zzZwzZ74zUEIJJfyfYaEGllQGVAGZlENdBy6Z2cSiYFTSKkkfS/pH/nBF0kFJdUW9AiRVASeAukD8DgNrzOySrwEzng18KaDzALXuG8W3AiStAvqBisBRNg40mtlPxbYCOgvgPO4bncWW+JpVeDQXRQhIygDfA00F5r0XuNfMrgclQFI98DDQCNQA5ZFXqoCWBVp8XwHRHeEqcN7loy/NbHBesyqpQ1KfFj/6nC+ZvFaApFrgPaCZpYVvgCfNbDiRAElNwGFg+RIt/X8H2s2s9wYCJDUAR4HqJX7++RN40MwGpgmQVAH0AQ2BPz4AHHPl8nBOAqtyFWQjsA6oL4Ada81sPDv7uwImod8kvSJp9RyS8O2SXnb/DYVd2Y9VSroQ4ANXJO2WVJmixqh0kzMWwL4LkiqRtDnA4D1zmfE8j9g9AezcnAHaPcfXdbfdnPZ2Yps6+DwAvO/Z1naTdApY7Xng48BDZnY1MpMVQBuw3iXc5Tnb0wBwBPjUzP6eoezuArZ6svM0geJLkvZEYnl3nkntoqROSbckSW2Suj3ZOIangc7GPJuUtNGdFIfmMeavktoSSKiW9LMPw30Q8JqkekmjCbOZRhuclLQjgYSNxUBAj6RyZ9ATgUJpUtJTCSR8vpAEXHAyWK5BXYFIGHOlepSAloUk4NEYgyoknQhEwhFJ0e8h6VSaQeerCb5uZgdi9utxYBNwOUD93hIVXswM4INCi6K9wAszFC2DwLOBDjHbYp59karIUnRdzYy/3ClqVklaUhfwTICj7K25OqA7a4wWagVsm4Me/xzwg2cCqqONFzO7DPxSCAJi436GUBgHHguQD2oTlJ55oSzP9ybccsttSJw1szdjFOSnI/8dTCGZHwcORp4Nx7y3B1iZ8/sm4MW8/Euxg5wIsS/HaAp3zeP4/G7obRDXI4jiTIA22H7Xdc7X+S3A5lC7QBQ357aq3VAjCeSkwUfAJrfvz+R8A9ADLAtZB+TinpjC5JMA+//jwPZZnF8G7J+L8z4IWB/zbG+gIujVWfLBW/NStVMmqaG4POJRsIjix7h8IGnLQuoBbQki5sVAJHyYm7YkNaRRtXwQ8G1cHpX0iKRrgUjYno17Sf0LrQhJUkdCeHWkVITGJI0k1QeS3ikGSUzOyJUJJNznYneuOCnpTldcxa2kP3xJYqOeSDjqZG8ShJLnE8TTuMS6Iyu1BW7djZqkfo9N0QOuYJmYQddfB7RG+gLTNzqAY9FrL+5/nwEbvDdJJe3zzOrhNP3AWRqmk55t3ZcBuj3b2gb0Sbrbo/NNzk7fFzu7s/E5EiC+rrmeQU0Kx2skvRFoOx2ZzlmSdgbsw49JetvtBpk8nM64d/cGbNtJ0s7cGyJlwHeEv+t3nqnLSgPAUOSGyG3AHUxdzqoJbEcvcL+ZTeTeEapzJKxgaeOcc/7Mf06D7kFrguS0VDAMtGadv+E47DT9tcChJej8ISfpD+abgTe45uOkFi8mnQ+JBVQ+d4VXuOptjavcyot8pq86mfwk8LWZnaOEEkoooYQSSojDv8AhQNeGfe0jAAAAAElFTkSuQmCC);background-repeat:no-repeat;border-radius:5px;position:absolute;right:13px;top:10px;height:48px;width:48px;background-size:80%;cursor:pointer;background-position:center;transition:background-color .2s}.webcam-wrapper .camera-switch:hover{background-color:rgba(0,0,0,.18)}"]
                }] }
    ];
    WebcamComponent.propDecorators = {
        width: [{ type: Input }],
        height: [{ type: Input }],
        videoOptions: [{ type: Input }],
        allowCameraSwitch: [{ type: Input }],
        mirrorImage: [{ type: Input }],
        captureImageData: [{ type: Input }],
        imageType: [{ type: Input }],
        imageQuality: [{ type: Input }],
        imageCapture: [{ type: Output }],
        initError: [{ type: Output }],
        imageClick: [{ type: Output }],
        cameraSwitched: [{ type: Output }],
        video: [{ type: ViewChild, args: ['video',] }],
        canvas: [{ type: ViewChild, args: ['canvas',] }],
        trigger: [{ type: Input }],
        switchCamera: [{ type: Input }]
    };
    return WebcamComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var COMPONENTS = [
    WebcamComponent
];
var WebcamModule = /** @class */ (function () {
    function WebcamModule() {
    }
    WebcamModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    declarations: [
                        COMPONENTS
                    ],
                    exports: [
                        COMPONENTS
                    ]
                },] }
    ];
    return WebcamModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var WebcamInitError = /** @class */ (function () {
    function WebcamInitError() {
        this.message = null;
        this.mediaStreamError = null;
    }
    return WebcamInitError;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var WebcamMirrorProperties = /** @class */ (function () {
    function WebcamMirrorProperties() {
    }
    return WebcamMirrorProperties;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { WebcamModule, WebcamComponent, WebcamImage, WebcamInitError, WebcamMirrorProperties, WebcamUtil };

//# sourceMappingURL=ngx-webcam.js.map